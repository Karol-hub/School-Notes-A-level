\documentclass{article}
\usepackage{graphicx} % Required for inserting images
\usepackage{wrapfig}
\usepackage{geometry}
\usepackage{tikz}
\usetikzlibrary{shapes.geometric, arrows}
\usepackage{pgf-pie}
\usepackage[backend=bibtex,style=alphabetic,sorting=ynt]{biblatex}
\usepackage[sharp]{easylist}
\usepackage[simplified]{pgf-umlcd}

\usepackage[T1]{fontenc}
\usepackage{inconsolata}
\usepackage{color}
\definecolor{bluekeywords}{rgb}{0.13,0.13,1}
\definecolor{greencomments}{rgb}{0,0.5,0}
\definecolor{redstrings}{rgb}{0.9,0,0}
\usepackage{listings}
\lstset{language=[Sharp]C,
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  escapeinside={(*@}{@*)},
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  basicstyle=\ttfamily
}

\tikzstyle{startstop} = [rectangle, rounded corners, minimum width=3cm, minimum height=1cm,text centered, draw=black, fill=red!30]
\tikzstyle{io} = [trapezium, trapezium left angle=70, trapezium right angle=110, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=blue!30]
\tikzstyle{process} = [rectangle, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=orange!30]
\tikzstyle{decision} = [diamond, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=green!30]
\tikzstyle{arrow} = [thick,->,>=stealth]
%https://www.overleaf.com/learn/latex/LaTeX_Graphics_using_TikZ%3A_A_Tutorial_for_Beginners_(Part_3)%E2%80%94Creating_Flowcharts

\bibliography{biblio}
\geometry{
a4paper,
total = {170mm,257mm},
left = 20mm,
top = 20mm,
}
\setlength{\parindent}{0pt}
\graphicspath{ {./Images/} }

\newcommand{\parBr}{\vspace{5mm}}%5mm vertical space
\newcommand{\myparagraph}[1]{\paragraph{#1}\mbox{}\\} %line break after paragraph declared

\begin{document}
\title{Computer Science \\ Advanced GCE H447 \\ Unit F453 \\[2\baselineskip]}
\author{\large Name: Karol Jeziorczak \\ Candidate Number: 4162 \\ Centre Name: Rugby High School \\ Centre Number: 31255 }
\date{}
\maketitle
\newpage
\tableofcontents
\newpage
\listoffigures
\newpage
\printbibliography
\newpage

\section{Abstract}
I decided to create a game for my coursework. I had researched the market to influence my game to make it more appealing to the target audience. Creating the game was very challenging and challenged my  limited understanding of c\#, and forced me to learn the language in greater detail, it also challenged the methods that I tend to favour when approaching a challenge forcing me to explore new ways of computational methods. I decided on a 2D rouge-like game with a heavy focus on melee combat and movement. For this I needed to make a character controller, dungeon generation algorithm, enemy AI and balanced items for the player. Each requiring it's own delicate calibration to make the game fun. 

\section{Introduction}
For my project I intend to create a 2D rouge like game which is focuses on melee combat. This game would be like Rain World with Celeste movement. I chose this style because there are few games which focus on melee combat and this would help it stand out amongst the other games, the rouge like aspect would allow every run to be unique and distinct. Allowing people to replay the game multiple times without getting bored.

\parBr

The melee combat will be close range and it will allow people to play in distinctive styles, for example people will be able to change their weapon and ability to suit the play style that they are looking for, making any play style viable.

\parBr

There will be progress through floors. When the player completes one floor they can move on and enter the next floor. At the end of each floor there will be a boss that the player must defeat to progress.

\parBr

The loot and map generation will be random meaning that the player cannot memorize the layout and do the same thing every time but need to adjust to the environment, making the game more challenging.

\parBr

I plan for there to be different enemies that have different attack patterns that will not be entirely random meaning that the player can learn how to effectively defeat the enemy. The enemy difficulty will increase as the player progresses through the floors.

\section{Analysis}
\subsection{Computational Methods}
Computational methods are computer-based methods which are used to solve problems. They are suitable for my project since I want to make an entertaining game. And I can accomplish this by creating features using the following methods.

\parBr

\textbf{Decomposition} – Splitting a large problem into smaller problems which are more manageable. This would help with my project as I am not going to be working in every aspect of the game at once, decomposition allows me to work on one part of the game at a time since debugging one small piece of code with a couple of errors is a lot easier than debugging the entire game code with many, many errors. It also allows me to work on different parts of the game independently from another part, since each problem is broken into it's own self contained module.

\parBr

\textbf{Divide and conquer} – Dividing a problem into smaller problems until they are small enough to be solved directly. This would allow me to develop one aspect of the game at a time and make steady progress on the game. Since each aspect is finished and polished by the time I move on to the next aspect. This can be utilised if decomposition doesn't break the code into small enough segments.

\parBr

\textbf{Abstraction} – Removing the additional detail allowing me to focus on the main points rather than wasting time trying to work on pointless detail that will not be noticed. This will allow me to use my time efficiently as the main features will get the most amount of time making the basics of the game reliable.

\parBr

\textbf{Modular design} – Subdividing the problem into smaller modules in my case these would be: physics engine, movement, abilities, characters etc. These allow me to priorities the modules which need more attention and keep organized as each module can have its own separate folder for all the things needed for that module.

\parBr

\textbf{Algorithms} – Algorithms allow me to implement features that do not need anything but computer processing to be solved. For example, enemies will use an algorithm to detect and attack the player, the scenery might be made by an algorithm etc. These allow the computer to do specialized processing for the problem that needs to be solved.

\parBr

\textbf{Selection} – Allows for choices to be made in the code. For example, if statement is a type of selection since a condition needs to be met for the code to be executed. This is useful in many scenarios, just to list a couple: if the player is in the air, they should not have the ability to jump. If the players health drops to zero they should be sent to the game over screen and many more.

\parBr

\textbf{Iteration (looping)} - Allows a certain piece of code to be ran multiple times, these can be count controlled of condition controlled. Loops which will continue to cycle the code until it has reached a stopping condition. These are useful since in a 2D game the players input needs to be recorded every frame to minimize latency, the code needs to sort through those inputs every to make the necessary adjustment to the character and environment all in the same frame. These tasks are repetitive therefore the code will be the same every loop and iteration is perfect for that.

\parBr

\textbf{Visualization} – The player will not be able to process the raw data outputted by the computer therefore it needs to be put in a format which is comprehensible for humans. There will be a lot of data processing while the game is running such as player position constantly moving, enemies moving and attacking the player. If that were outputted as a string of numbers to the player, they would have no idea what is going on therefore visualization is used to allow the user to interact with the program.

\parBr

\textbf{Pattern recognition} – It would be useful for the computer to recognize patterns as a certain pattern could be used as a condition for selection this could be useful as when the player attacks the computer could recognize this and react accordingly to make the fight interesting. Or it can be used in fighting games to make a move since in some games you can chain inputs to do a special attack.

\parBr

These computational methods are suitable for solving my problem because each problem can be broken down into smaller sections that are able to be solved by a machine. 

\subsection{Researching The Problem}

\subsubsection{Risk of Rain 2}

\begin{figure}[h]
\includegraphics[width=\linewidth]{ROR 2 ss}
\caption{\cite{ROR2ss} Risk of Rain 2 Screen shot}
\end{figure}
Risk of Rain 2 is a rogue like, third person shooter. A rogue like game means that when you die in the game you must restart the entire game, which means that it does not take long to complete and it can be replayed multiple times, since it has a large variety of items which can be combined to make many unique runs. It has a unique concept since as the time goes up so does the difficulty, meaning that the more time you spend looting the more powerful enemies become creating a unique stressful and fast paced shooter. 

\myparagraph{Controls}
\begin{tabular}{c|l}
Key/Button & Action                                                                       \\ \hline
WSAD       & Moving Around                                                                \\
Space      & Jump                                                                         \\
E          & Interact with the environment (open crates etc.)                             \\
Q          & Activate equipment (item that can be used by every character)                \\
Ctrl       & Toggle sprint (to move faster)                                               \\
M1         & Primary Skill (unique to character, usually damaging)                        \\
M2         & Secondary Skill (unique to character, usually damaging)                      \\
Shift      & Utility Skill (unique to character, usually movement)                        \\
R          & Special Skill (Unique to character, usually heavy damage, and long cooldown) \\
Tab        & Info Screen (shows the statistics of the current run)                        \\
M3         & Ping (allows players to communicate in game)                                
\end{tabular}

\myparagraph{Characters}
Commando and Huntress – Both are beginner friendly characters which have a basic set of skills and utility to ease the player into the game. They are the first characters you unlock and they are both good characters even after the player has learn to play the game. 

\parBr

Every character apart from these two needs some sort of challenge to be completed before the player gains access to them. This allows the player to progress at their own pace. 

\parBr

Acrid, Artificer, Bandit, Captain, Engineer, MUL-T and REX – Once these characters are unlocked, they expand the possible play styles possible to the play allowing the player to play the game in any way they want to for example, Engineer has turrets and a shield if the player wants to bunker down, while Bandit has an invisibility cloak and shotgun allowing for the player to get close and personal. 

\parBr

Loader and Mercenary – Both have the highest skill ceiling (lots of things to master) and both have lots of unique tech (advanced strategies to use utility to achieve a certain result) for example Loader can launch out her pylon and grapple to it immediately after launching the player a great distance 

\parBr

Railgunner and Void fiend – Both DLC characters which is a good example of the developers expanding the play style since none of the other characters had long range and these characters fit that style perfectly since Railgunner has a rail-gun which is like a sniper allowing the player to keep their distance and pick of enemies one by one. 

\parBr

Heretic – A secret character which is unique since they cannot be unlocked, and the character is bound by the run as they are unlocked by picking up a combination of items on that run. 

\myparagraph{Aim of the game}
The aim of the game is to get loot and activate the teleporter, after this a boss will spawn, which you must kill to progress. You get teleported to a different stage and the process repeats until stage 5 and after that you get teleported to the moon to kill final boss (Mythrix) or obliterate yourself which has a more secret ending which needs the player to enter a portal on stage 8 after they loop (return back to stage 1 and keep all their items), sometimes a large purple portal can appear which teleports the player to a different realm (with some pretty interesting lore) and they have to defeat Voidling which gives the player an alternate ending. 

\myparagraph{Target demographic}
Teens and older since the game contain blood, drug references and fantasy violence. It is aimed at people with all skill types as the game has different difficulty rating which allows the player to play at the level that they are comfortable with.  

\paragraph{Good Qualities}
\begin{itemize}
\item The game is very beginner friendly because of the difficulty options provided.
\item The variety of items allows the player to replay the game with many different combinations and the game does not feel repetitive. 
\item The different ending makes the player want to experience them all.  
\item The variety in character makes any play style suitable. 
\item The game is never “too easy” since there are eclipse challenges which get progressively harder
\item The many secrets in the game allow insentiences the player to explore and solve puzzles to unlock new aspects of the game.
\end{itemize}


\paragraph{Bad Qualities}
\begin{itemize}
\item Once you loop a lot the game gets very chaotic and resource intensive because there are so many enemies with different attributes that can create lots of projectiles that slow down the game a lot.  
\item Some things can kill you in one hit making death unavoidable in some cases which can feel unfair. 
\item Sometimes you get runs where you get no good items, and the game becomes a lot more difficult because of bad luck. 
\end{itemize}


\paragraph{What I would include}
\begin{itemize}
\item The variety in characters and the play styles that the game allows would allow my game to be playable by anyone.
\item The different difficulties allowing the player to play at a level that their comfortable with, this would make the game approachable to anyone with any skill level.
\end{itemize}


\subsubsection{Celeste}
\begin{figure}[h]
\includegraphics[width=\linewidth]{Celeste ss}
\caption{\cite{Celss} Celeste Screen shot}
\end{figure}
Celeste is a challenging 2D platformer where the aim is to give precise inputs that will clear the level and allow you to progress into the next room. It takes a long time to complete as the game is very difficult and constantly introduces new features that are harder than the last.

\myparagraph{Controls}
\begin{tabular}{c|l}
Key/Button & Action        \\ \hline
WSAD       & Moving Around \\
Space      & Jump          \\
K          & Dash          \\
L          & Grab         
\end{tabular}

\myparagraph{Characters}
Madeline is the protagonist of the game and as the game progresses, as the game progresses they get more and more abilities and the level design reflects this as the game presents rooms that can only be solved with the new skill that the player was shown. The game never gives the character any new skills are just shown to the player and never granted or unlocked meaning that the player can revisit earlier levels and complete them in newer and more efficient ways. The player does get an extra dash in some of the later rooms in the game and this is the only upgrade that the player gets.

\myparagraph{Aim of the game}
The aim is to get to the top of the celeste mountain climbing the mountain one room at a time. Rooms get harder the further you progress in the game, the length of these rooms can vary drastically, the same applies to the difficulty. The game itself doesn't have that much levels however each level is very difficult which makes completing one very rewarding.

\myparagraph{Target demographic}
Anyone as the game doesn't have any violent or difficult topics discussed, however it will cater better to a slightly older audience because of it's difficulty. The game also targets people who are more experience in platformers as the difficulty of the levels scales quickly.

\paragraph{Good Qualities}
\begin{itemize}
\item Beating a room feels rewarding and it makes the player want to continue playing.
\item The movement is very simple which makes it easy for anyone to start.
\item The movement feels fun due to the combinations with different  movement techniques. 
\item The movement feels consistent, if you die it feels like it's your fault and not the game being unfair.
\end{itemize}

\paragraph{Bad Qualities}
\begin{itemize}
\item Getting stuck on one room can be very frustrating.
\item To progress far into the game you need to dedicate a lot of time and have a lot of skill.
\end{itemize}

\paragraph{What I would include}
\begin{itemize}
\item A similar art style, since the simple pixel art would be easier to implement than hand drawn characters.
\item Similar movement system, but something that isn't as complicated so it doesn't overwhelm the player since I also want to add a combat system.
\end{itemize}

\pagebreak

\subsubsection{Rain World}
\begin{figure}[h]
\includegraphics[width=\linewidth]{Rain world ss}
\caption{\cite{RWss} Rain World Screen shot}
\end{figure}
Rain world is an open world game meaning that the player can go explore anywhere to their heart's content. It's also very difficult, and focuses on treating the player as part of the ecosystem rather than a separate entity, for this reason enemies treat the player as any other rival creature and focuses on their own survival rather than killing the player, which is common in most other games.

\myparagraph{Controls}
\begin{tabular}{c|l}
Key/Button & Action        \\ \hline
WSAD       & Moving Around \\
Space      & Jump          \\
E          & Grab          \\
Q          & Throw         \\
Z          & Map           \\
Escape     & Pause        
\end{tabular}

\myparagraph{Characters}
The player plays as a slugcat which is a small creature with the ability to wield rocks and spears. They can also befriend other wild creatures. They can also interact with scavengers if the player's reputation is good with the scavengers, however this isn't the case for all slugcats as scavengers will become hostile if the player's reputation is low. 

\parBr

Monk - The easy mode of rain world, where enemies are less common and less aggressive. This character is good for people playing the game for the first time as it allows them to experience the game in a less harsh environment than usual.

\parBr

Survivor - Regular difficulty of the game

\parBr

Hunter - Hard mode of rain world where some special tougher enemies spawn that don't usually spawn, enemies are also more common and aggressive. There is also a time limit as the hunter has a limited amount of cycles (days) unlike any of the other characters, hunter also has the ability to consume dead animals.

\parBr

Rain world also has a DLC called downpour which adds 5 new characters, where each character has unique abilities and objectives, the different characters are unique to the base game characters as they have their own abilities which also come with their downsides. Each character is also set at a different time in the timeline meaning that the layout of the game will be similar however each room will be different for each character and the enemies in that area will also be different. These new characters each require a different approach for the game due to their different downsides, for example gourmand gets tiered after throwing a spear, forcing the player to plan their combat as they will get tiered if they spend too long in combat. Whereas the saint isn't able to use spears because it's a pacifist, but they have a grapple which it can use to traverse the land faster, forcing the player to avoid combat at all costs. 

\myparagraph{Aim of the game}
The aim for each character in the game varies, however they all need to progress through the environment to reach their goal, often resulting in combat with the wildlife. The player must also gain enough food to be able to sleep in a shelter and avoid the rain that comes at the end of each cycle (game equivalent of a day). Dying results in the player respawning in the shelter they previously slept in and losing a karma point, however for each successful cycle that the player completes they will gain a karma point. Karma is important as it allows the player to traverse between regions, since regions are separated by karma gates which only let you through if your karma is above a certain level. 

\myparagraph{Target demographic}
Anyone as it doesn't contain any graphic scenes or references to difficult topics. However the game caters more to people who are willing to spend time trying to understand it as it's a very challenging game which is very harsh for a new player, lacking any kind of tutorial or explanation. 

\paragraph{Good Qualities}
\begin{itemize}
\item Game play is fun and keeps the player engaged due to the many things that the player can do.
\item Game has a high skill ceiling meaning there is always a way the player can improve.
\item Movement is incredibly fun and feels exceptionally smooth. 
\item Lack of permanent upgrades makes the game focus on skill rather than items and unlocks.
\item Completing a cycle is very rewarding.
\item Player is treated as part of ecosystem rather than separate entity, meaning they are treated as every other enemy is by the other enemies which makes it feel more realistic.
\end{itemize}

\paragraph{Bad Qualities}
\begin{itemize}
\item Difficult to get into due to no tutorial, there is no way of knowing what to do when you start and the player has to figure it out for themselves, which can be enough to deter some players.
\item Game is very unforgiving and a small mistake can result in the player getting killed and losing a lot of progress.
\item The map is very large and the in game map system is very unreliable so it's often played with a map open on a separate tab or device.
\end{itemize}

\paragraph{What I would include}
\begin{itemize}
\item A similar combat system, as it is simple but still fun and has lots of ways the player can express their skill.
\item Treating the player as part of the ecosystem, as it makes the game feel more alive.
\end{itemize}

\subsection{Stakeholders}
My game would be suited for people who have more experience with games, it will be suitable for any age over the age of twelve (might be a too violent for children under the age of twelve). A stakeholder would also be important as they could give me direct feedback for the game to improve it and make it a more enjoyable experience. They would play the game as they often play games as a source of entertainment the survey conducted in a later section shows what type of games people play and therefore would be willing to try.

\parBr

Therefore, Ethan Armstrong would be a suitable stakeholder. He is 16 years of age therefore he fits the target demographic. He will give feedback through play testing and according to the feedback I will be able to adjust the difficulty and balance the aspects of the game to fit the genre and style I am going for. The feedback given to me by him will allow me to adjust the game to make it more enjoyable. 

\parBr

Daniel Cabrel would also be a stakeholder as they are new to gaming therefore, I will be able to make the game more beginner friendly to expand my target audience and make it more appealing to more people. He will also give feedback through play testing and interviews allowing me to make the game easy to pick up regardless of skill. 

\parBr

I have chosen these people since they are part of my target demographic and they will help me to make the game easy to pick up yet challenging.

\subsection{Interview with Stakeholder}
\begin{flushleft}
I – Interviewer (Karol Jeziorczak) \linebreak
S – Stakeholder (Ethan Armstrong) 
\end{flushleft} 

\parBr

I: Everything you say here will be recorded and used for development of my game; however, it will not be shared with any unauthorized personnel and your data will protected under the GDPA 

\parBr

S: I understand and agree to these terms. 

\parBr

I: Question 1. What is the most important feature to you in a game? 

\parBr

S: Exploration is very important to me; I love finding out hidden mechanics and secrets. 

\parBr

I: Question 2. How important is difficulty scaling with progress to you? 

\parBr

S: It is important to make the game challenging as it will make it more fun to overcome. 

\parBr

I: Question 3. How often should there be boss fights? 

\parBr

S: A bit after a new mechanic gets introduced so I have time to get used to it however the boss fight will be a test to see if the player can use the gimmicks 

\parBr

I Question 4. What type of playstyle do you usually go for? 

\parBr

S: I usually go for a large health build with heavy weaponry 

\parBr

I: Question 5. Are there any specific features you would like to see? 

\parBr

S: I would like to see a power slide because it makes the game seem fast paced. 

\parBr

I: Question 6. What are some qualities of a good combat system? 

\parBr

S: Enemies not having insane amounts of health as it slows down the pace of the game and makes killing them seem like it takes too long. So, with melee weapons there should be more blocking and skill involved rather than just hitting enemies and them dying? 

\parBr

I: Question 7. What should the final boss look like? 

\parBr

S: The final boss should be an enemy foreshadowed by the previous environments that has different mechanics from the different bosses that combine them all into one where they need to be interchanged, with a satisfying dying animation for the final boss.  

\parBr

I: Question 8. How should the inventory management system work? 

\parBr

S: I think that there should be a very limited amount of inventory room so that management and planning become very important. Also, so that the focus of the game isn't shifted too much from the combat, as it is the main focus of the game. 

\subsection{Letter to Stakeholder}
%Paragraph 1 - Introduce yourself and coursework 
%Paragraph 2 – why you have chosen them and what you need from them (interviews and game testing) 
%Paragraph 3 – GDPR (General Data Protection Regulation), data protection explain how you will follow these rules 
%Paragraph 4 – Thank them for working with you 
\begin{flushright}
31 Bucannon Road \linebreak CV22 6AZ \linebreak 20/11/2022
\end{flushright}

Dear Ethan Armstrong, 

\parBr

\begin{flushleft}
My name is Karol Jeziorczak. I am studying computer science (OCR specification) at Rugby High School; the coursework requires me to create a game. \linebreak
I am asking you to become a game tester for my game so that I can get feedback from you as to how to improve the game. In the future I will ask you to give me feedback on the game to improve the quality and usability of the game, this will be in the form of interviews and game testing. This will hopefully improve the quality of the game and allow me to develop this project further into a fully functional product. \linebreak
All the data gathered will be kept secure in order with the GDPR (General Data Protection Regulation). This means that your data will be kept secure and will not be shared with any unauthorized personnel. I will do everything that I can to protect your data. However, if the data will get leaked, you will be the first to get notified.  \linebreak
Thank you for your time and co-operation (if you choose to). I am looking forward to working with you.
 
\parBr

Sincerely, \linebreak Karol Jeziorczak
\end{flushleft}

\subsection{Questionnaire}
\begin{figure}[h]
\includegraphics[scale=0.65]{Questionnaire Screenshot}
\caption{Questionnaire Header}
\end{figure}

A questionnaire will allow me to analyse the market and make a game that people want to play. It also allows me to ask the intended audience for any features that they want.

\paragraph{Analysis}
\flushleft{Q1: What is your age?} \linebreak

\begin{tikzpicture}
\pie [text=legend]
    {6/less than 12 (1),
    67/between 12 and 17 (12),
    17/between 18 and 25 (3),
    11/above 25 (2)}
\end{tikzpicture}

We can see that the target demographic is teens and above meaning that the game can include some violence. It is important to make the game appropriate to the target demographic as they will be the majority of the player base. 

\parBr

\flushleft{Q2: How much do you play games a week?} \linebreak
\begin{tikzpicture}
\pie [text=legend]
    {6/less than 1 hr (1),
    28/between 1 and 3 hours (5),
    39/between 4 and 8 hours (7),
    17/between 9 and 14 hours (3),
    11/above 15 hours (2)}
\end{tikzpicture}

It is important to balance the progress made and the time invested as if people only play 1-2hrs a day as shown by the questionnaire, it is important to make the player feel like they made progress in that time so that they are willing to continue playing. This could be implemented by each run being 30-40 mins allowing the user to have a couple runs in a session.

\parBr

\flushleft{Q3: What platform do you play games on?} \linebreak
\begin{tikzpicture}
\pie [text=legend]
    {28/Console (5),
    11/Mobile (2),
    61/PC (11)}
\end{tikzpicture}

Most people answered replied that they play on pc meaning that it should be ported to pc first. A significant amount of people also play on console so it would be good to port the game to console if possible. 

\parBr

\flushleft{Q4: what genre of games do you play?} \linebreak
\begin{tikzpicture}
\pie [text=legend]
    {28/Rougelike or Rougelite (5),
    11/Stratergy (2),
    22/Platformer (4),
    11/Fighter (2),
    17/Survival (3),
    11/Open World (2)}
\end{tikzpicture}

\parBr

Most people answered Roguelike/Rougelite and platformer meaning I should focus on these two aspects the most when making my game. Survival will be implemented though planning ahead this might be what routes to take and the risk associated with those routes as well as the risk of combat. As well as management of resources to make sure you survive to the next stage. 

\flushleft{Q5: What mechanics are important to you in a game?} \linebreak
\begin{tikzpicture}
\pie [text=legend]
    {39/Gameplay - combat (7),
	28/Gameplay - movement (5),
	0/User interface (0),
	11/Story (2),
	17/Different playstyles (3),
	6/Permanent progression (1)}
\end{tikzpicture}

\parBr

Combat and movement were the most common option so they should be the most polished systems in the game. Though different playstyles was something I should consider. Permanent progression wasn't a popular choice so a roguelike style would be more suitable 

\flushleft{Q6: how many skills should each character have?} \linebreak
\begin{tikzpicture}
\pie [text=legend]
    {33/1 (6),
    50/2 (9),
    17/3 (3)}
\end{tikzpicture}

\parBr

Most people answered 2 so it would be important to make the skills distinct and unique to allow for different play styles. One ability could be active that the user can activate when needed e.g. throwing grenade and it will have a cool down. The other ability could be a utility skill which can be picked regardless of character and is a limited resource and refreshes once a special item is picked up e.g. throwing knife that does damage, refreshes when more are picked up. There could also be a passive ability that the player doesn't need to do anything to activate it, it will be permanently active in the background (e.g. increased movement speed), this can make every character feel unique. 

\flushleft{Q7: Should each character have their own weapon in their class or be able to?} \linebreak
\begin{tikzpicture}
\pie [text=legend]
    {37/Weapon is locked to class (7),
    63/Weapon isn't locked to class (12)}
\end{tikzpicture}

\parBr

The majority wanted to have weapons that are picked up and not locked to a class therefore I will give each character a starting weapon and give them the ability to change this weapon if they wish to, allowing the player to experiment with different weapons that may suit their play style.

\subsection{Analysing Market}
Steam does a hardware analysis on all of it's users every month so I will be able to make a game that will meet the requirements of the majority of players. So all the data in this section is taken from \cite{SHS}

\myparagraph{System OS Analysis}

\begin{figure}[h]
\centering
\includegraphics[width = 0.4\textwidth]{steamOSsurvey}
\caption{\cite{SHS} Steam OS statistics}
\label{steam OS statistics}
\end{figure}

Deciding which systems I will be able to support is going to be an important decision I have to make to make sure that the users can play the game us. Figure \ref{steam OS statistics} shows us that the overwhelming majority of players use windows, this tells me that I should prioritise porting the game to windows as it will make it available to the most amount of players as possible. Mac OS (OS x) only account for a small percentage of players. The difficulties that come with porting my game to Mac simply makes it an inefficient use of time. Linux also accounts for a small percentage of players however porting to Linux is very easy in Godot so it may be something to consider in the future if I have time.

\parBr
\parBr

\myparagraph{Hardware Analysis}
\begin{figure}[h]
\centering
\includegraphics[width = 0.4\textheight]{steamSurvey}
\caption{\cite{SHS} Steam Hardware Statistics}
\label{steam statistics}
\end{figure}

I intend to make a 2D game. These types of games don't tend to be resource intensive. The most important statistics in figure \ref{steam statistics} are system RAM, Intel CPU speeds (More players use Intel CPUs rather than AMD CPUs so this is a valid statistic to use), Physical CPUs, VRAM, Free Hard Disk Space (the ones with a red mark next to them). None of the statistics should be limiting for my project as they would be more important to consider for a 3D game using a fancy rendering system. However my game is 2D so it should be able to run smoothly on most devices.

\subsection{System Requirements}
\paragraph{Minimum Hardware Requirements}
\begin{itemize}
\item Processor:   
\item Graphics Card:   
\item Memory:   
\item Storage:   
\item Sound Card: yes
\end{itemize}

Input devices:
\begin{itemize}
\item Keyboard – allows you to input characters 
\item Mouse – Inputs 2D vector coordinate for mouse position 
\end{itemize}

Output devices:
\begin{itemize}
\item Display – Outputs image 
\item Speakers – Outputs sound 
\end{itemize}

\paragraph{Minimum Software Requirements}
\begin{itemize}
\item OS: Windows 10+   
\item DirectX version: 12   
\end{itemize}

\subsection{Limitations}
Compared to the large studios that produced the games that I researched I have a significant amount of limitations that could slow down the progress of my game development. Such as manpower as studios usually consist of many specialised and trained people. However I am trying to make a game on my own, this means I will need to do everything on my own, from game assets and art to audio design and code. This could be mitigated slightly by the free assets available online which would save me time as I don't have to create them myself.

\parBr

Another limitation is my knowledge and experience in developing games as I only have experience developing one small game for a game jam over the course of a couple days. The project was very limited and used GD script, whereas I would like to use c\# to develop my game. I could overcome  this by following tutorials and doing research to make myself more comfortable with developing my own methodology and ideas.

\parBr

I am also limited by time since there is a deadline I must reach so  I can't continuously develop the game over the course of a couple years. This can be less impactful with good time management and use of abstraction so that I can focus on the main points of the game when developing and spend less time on small features that will go unnoticed for the most part.

\subsection{Essential Features}
One essential feature is the user interface as it allows the user to navigate any menus and displays any important information to the player. The main menu is the first screen that a player would see therefore it is important to give a good  first impression and set the tone of the game and allows the user to start a game and customise their settings. The pause menu is also an important feature of the user interface as it allows the player to pause the game and customise their settings. These things are standard in most games so it would be good to implement it in my game. The HUD (Heads Up Display) is the only user interface that the user sees when they are in game, so it's important to keep it clean and out of the way as it will be overlayed on the users screen at all times. It will also be important to have it display the relevant information, such as the player's health, inventory, and possibly a timer. However not all players will want all of this information on screen at all times so it will be important for the HUD to be customizable to suit a player's needs.

\parBr

Audio is another key feature of games as audio queues can help players fight an enemy, or get feedback since they can hear the sound of their character getting hurt and immediately know that their health has went down without having to look at their health bar. Or when a hit from the player connects with an enemy they know that they damaged the enemy and it also adds to the user experience. This is observed in all the other games I researched, therefore it would be good to include. In game music also sets the tone of the game since if the game changes theme to a combat theme, the player can prepare for combat before the enemies show up.

\parBr

The type of gameplay that I will focus on can be split into two main sections, player combat and player movement. \linebreak
Having a good combat system is important as the player will engage with it very often so it's important for it to feel responsive and fun. This could be done by having a variety of weapons that work well together with the movement system. \linebreak
The movement system will be how the player traverses the level, so having a responsive and fun movement system will be important as the player will always be interacting with it. Allowing for the player to combine movement and combat would create a lot of combinations the player could discover and experiment with.

\parBr

Level generation will also be important as it creates the environment the player will experience the game in. So it needs to work well with the movement system for the levels to be easy to traverse through. Since if the player is unable to reach an important room that could hinder their progress in the game.  

\subsection{Success Criteria}
% SS of success Criteria
\begin{easylist}
# \large{\textbf{User Interface}}
## \textbf{Main Menu}
### Does it have a new game button? \linebreak
Allows the player to start the game.
### Does it have an options button? \linebreak
Allows the player to customise the game to suit them
### Does it have a tutorial option? \linebreak
Takes the player to a tutorial level where they can learn the game, important for new players who are playing for the first time.
### Does it have a interesting background? \linebreak
Gives a good first impression to the player when they open the game.
### Does it have a quit game button? \linebreak
Allows the player to close the game.
#### Does it ask you "are you sure"? \linebreak
Makes sure that the played didn't press the button by accident.
## \textbf{Pause Menu}
### Does it pause the game? \linebreak
Allows player to take a break if they need to.
### Is there an options button? \linebreak
Allows the player to change setting in game in case they need to.
### Is there an exit to main menu button? \linebreak
Allows the player to quit the current run and return to the main menu.
#### Does it tell you "The current run will be ended"? \linebreak
Makes sure the player didn't press this button by accident and occidentally quits their run
## \textbf{HUD (Heads Up Display)}
### Is there a health bar?
### Is there a current level box?
### Is there a timer?
### Are there small indicators for status effects?
### Is the HUD customisable?
## \textbf{Inventory}
### Can you drop items?
### Are there item slots?
### Can you rearrange your inventory?
# \large{\textbf{Audio}}
## \textbf{Main Menu}
### Is there some sort of music?
### Do the buttons make a sound?
## \textbf{In Game}
### Is there boss music?
### Does the game have hitting sfx?
### Does the game have a sound for getting hit?
### Does the game have music?
### Does the game have a sound for dying?
# \large{\textbf{Gameplay}}
## \textbf{Level Generation}
### Does it create a level in a reasonable amount of time?
### Are there objects you can interact with that give items?
### Are enemies spawned?
### Is there a safe starting room?
### Is there a boss room at the end?
### Is there variety between levels
## \textbf{Player Combat}
### Does the player die when they have 0 health?
### Can the player melee swing?
### Can the player block?
# \large{\textbf{Visuals}}
\end{easylist}

\section{Designing the Solution}
\myparagraph{Decomposition of the problem}   
This is one of the computational methods that I am going to use for my game. This is important as it allows me to think of how the game will work at a basic level. 

\parBr

\myparagraph{Variables}
stores some sort of data in main memory \linebreak \textbf{Data Types}
\begin{itemize}
\item Integer – whole number   
\item Float – real number   
\item Character – single letter/symbol   
\item String – series of characters   
\item Boolean – true or false   
\end{itemize}

CONSTANT – represented as capitalized with underscores
\linebreak
variable – represented as lowercase with underscores 

\subsection{Folder Set up}
% SS of folder setup when complete

\subsection{Main Menu}
The main menu will be there to greet the player once they open the game and allow them to choose what they would like to do.

\parBr

These will be in the form of buttons that the user can click on.

\parBr

% idk some flowchart or something
\begin{center}
\begin{tikzpicture}[node distance=2cm]
\node (start) [startstop] {Start};
\node (in1) [io, below of=start] {Player Presses a button};
\node (load) [startstop, below of=in1, yshift = 0cm] {Game Starts};
\node (pro2) [process, left of=load, xshift=-2cm] {Settings Load};
\node (in2) [io, below of=pro2, xshift =0cm] {Player returns to main menu};
\node (quit) [startstop, right of=load, xshift = 2cm] {Quits Game};
\draw [arrow] (start) -- (in1);
\draw [arrow] (in1) -- (load);
\draw [arrow] (in1) -- (pro2);
\draw [arrow] (in1) -- (quit);
\draw [arrow] (pro2) -- (in2);
\draw [arrow] (in2) -- (in1);
\end{tikzpicture}
\end{center}

\subsection{Dungeon Generation}
The Generation algorithm that I used is a modified version of the algorithm used in {\cite{Gen_Alg}}. The stages I used can be summarised with the key points:
\begin{itemize}
\item{Create rooms}
\item{Spread rooms}
\item{Delaunay triangulation}
\item{Remove random amount of edges}
\item{Make sure all rooms are accessible}
\item{Turn edges into horizontal and vertical}
\item{Generate corridors}
\item{Turn into tile map}
\end{itemize}
Some other miscellaneous algorithms used in generation
\begin{itemize}
\item{Turning list of edges to graph}
\item{Turning graph to list of edges}
\end{itemize}

\subsubsection{Create Rooms}
\begin{figure}[h]
\centering
\includegraphics[height = 0.2\textwidth]{room layout}
\includegraphics[height = 0.2\textwidth]{room layout1}
\caption{Room Layout}
\label{Room Layout}
\end{figure}
Begin with generating a defined amount of rooms. Rooms are pre-made layouts that a room as seen in figure \ref{Room Layout}. Originally I generated a cube and gave it a random size, but this would be problematic down the line since when it comes to creating a tile map it would be difficult to generate a room that would be playable.

\subsubsection{Spread rooms}
Once all the rooms are all generated in a confined area they need to be spread out until they are no longer overlapping. To separate the rooms I iterated through each room object and check it for overlapping areas. I found the difference in positions to get the vector of the room relative to the original room being considered, using this I can find the direction that the room should be moved in. This idea was taken from \cite{Dis_Alg}

\begin{figure}[h]
\centering
\includegraphics[width = 0.5\textwidth]{sep_vecs_rects}
\caption{\cite{Dis_Alg} Room Movement Direction}
\label{Room Movement Direction}
\end{figure}

The only major difference in the way that I implemented was that I multiplied the vector by the reciprocal of the magnitude, this would make it so that when there is a colliding room closer to the room being considered it's effect on the displacement of the room is much greater than if it was far from the center of the room
\linebreak
\textbf{Pseudocode}
\begin{lstlisting}
//this piece of code is called every frame until it develops as solution
checkedRooms = 0
for each room in all_rooms_generated
{
	if room.HasOverlappingAreas()
	{
		direction = Vector2.Zero //sets value to (0,0);
		for each overlappingRoom in room.GetOverlappingAreas()
		{
			displacement = room.Position - overlappingRoom.Position;
			direction += (1/displacement.Length()) * displacement.Normalised;
			//takes reciprocal of displacement and adds it to direction
		}
		//rounds towards nearest int and multiplies by step, which is a variable that scales up with amount of rooms as more rooms will need to spread further which optimizes the algorithm
		direction.X = (float)Math.Round(direction.X) * step;
        direction.Y = (float)Math.Round(direction.Y) * step;
        room.Position += direction
	}
	else
	{
		checkedRooms +=1;
	}
}
if (checkedRooms == amountOfRooms)
{
	//each room has been checked and doesn't have overlapping areas so algorithm finished	
	//move onto next stage of generation
}

\end{lstlisting}
Once complete a result typically looks as such
\begin{figure}[h]
\centering
\includegraphics[height = 0.2\textwidth]{rooms seperated}
\includegraphics[height = 0.2\textwidth]{spread rooms}
\caption{Result of room separation}
\label{room seperation result}
\end{figure}

After this process a pre-defined amount of rooms are deleted so that there are gaps in between the rooms, removing 60\% of the rooms works well. On top of this the position of each room is multiplied by 2 to spread the rooms further

\begin{figure}[h]
\centering
\includegraphics[height = 0.3\textwidth]{deleted rooms}
\includegraphics[height = 0.3\textwidth]{deleted rooms1}
\caption{Result of room deletion}
\label{room deletion result}
\end{figure}

\subsubsection{Delaunay Triangulation}
The algorithm used in this section was taken from \cite{BW_alg}(Bowyer–Watson algorithm). For the algorithm to function I needed a data structure for points, which link the Area2D, position and a list of points which the point is connected to. Edges are an array of two points which represents a connection between two points. Triangles are an array of three edges and hence three points, from these a circumcircle can be drawn, which is important for the Bowyer-Watson algorithm, this is represented as a vector2 storing the circumcentre and a float for the radius.
\linebreak
\textbf{Pseudocode} \linebreak
\textit{The pseudocode was taken from} \cite{BW_alg}
\begin{lstlisting}
function BowyerWatson (pointList)
    // pointList is a list of points defining the points to be triangulated
    triangulation := empty list of triangles
    add super-triangle to triangulation // must be large enough to completely contain all the points in pointList
    for each point in pointList do // add all the points one at a time to the triangulation
        badTriangles := empty list of triangles
        for each triangle in triangulation do // first find all the triangles that are no longer valid due to the insertion
            if point is inside circumcircle of triangle
                add triangle to badTriangles
        polygon := list of edges
        for each triangle in badTriangles do // find the boundary of the polygonal hole
            for each edge in triangle do
                if edge is not shared by any other triangles in badTriangles
                    add edge to polygon
        for each triangle in badTriangles do // remove them from the data structure
            remove triangle from triangulation
        for each edge in polygon do // re-triangulate the polygonal hole
            newTri := form a triangle from edge to the new point
            add newTri to triangulation
    for each triangle in triangulation // done inserting points, now clean up
        if triangle contains a vertex from original super-triangle
            remove triangle from triangulation
    return triangulation
\end{lstlisting}
\parBr
The pseudo code states that there needs to be triangles, edges and points. These structures can be achieved with object oriented programming as I can make a class with all the relevant attributes and methods for each data structure mentioned.

\begin{figure}[h]
\centering
\includegraphics[width = 0.4\textwidth]{rooms deluaney triangulation just edges}
\includegraphics[width = 0.4\textwidth]{rooms deluaney triangulation}
\includegraphics[width = 0.4\textwidth]{rooms deluaney triangulation stress test}
\includegraphics[width = 0.4\textwidth]{deluaney triangulation stress test}
\caption{Result of Bowyer–Watson algorithm}
\label{bwa result}
\end{figure}

\subsubsection{Remove random amount of edges}
Figure \ref{bwa result} shows the result of the algorithm, however this many corridors would be overwhelming for players and would result in each room having 4-5 corridors leading out of it, which would could overwhelm the player. Other rouge-like games usually contain 2-3 corridors leading out of it, this would mean I needed to delete some of the edges but still make sure all the rooms are accessible.

\parBr

Currently the mesh is stored as a list of edges. So to remove a certain amount I can make a copy of the list and then remove a random amount of edges. However C\# passes the list by reference so any alterations on the copy of the list will also alter the original. Therefore I made a new empty list and added a random amount of edges from the original list.
\linebreak
\textbf{Pseudocode}
\begin{lstlisting}
float edgeDeletingFactor; //number between 0-1 representing how much edges to keep
List<Edge> polygon; //List of edges from triangulation stage
List<Edge> edgeList = new List<Edge>();
List<int> indexList = new List<int>();
int newIndex;
while (edgeList.Count() < (int)(polygon.Count()* edgeDeletingFactor))
{
	newIndex = RandomIntBetween(0,polygon.Count())
	//this part ensures there is no duplicates in edgeList
	if (!indexList.Contains(newIndex))
	{
		edgeList.Add(polygon[newIndex]);
		indexList.Add(newIndex);
	}
}
\end{lstlisting}
\parBr
\begin{figure}[h]
\centering
\includegraphics[width = 0.4\textwidth]{deleted edges no rooms}
\includegraphics[width = 0.4\textwidth]{deleted edges}
\caption{Deleting edges result}
\label{deleting edges result}
\end{figure}

However this creates a problem as now some of the rooms are inaccessible because they have no edges connecting to them or are in another inaccessible section. This is solved in the next section.

\subsubsection{Make sure all rooms are accessible}
This section can be decomposed into smaller problems. That being detecting sections and connecting sections. First comes detecting sections, this is accomplished more easily when the the graph is represented with list of points along with each point having a list of points it's connected to. Currently the graph is represented as a list of edges. This can be done with a simple algorithm explored further in the "Turning list of edge to graph" section.
\linebreak
\textbf{Pseudocode} \linebreak
\textit{Algorithm for detecting weather a new section needs to be made at the current point}
\begin{lstlisting}
function DetectSections(List<Edge> edges)
//list of section, each section is a list of points
List<List<Point>> sects = new List<List<Point>>()
List<Point> graph = MakeGraph(edges)
bool exists = false
for each point in graph
{
	//check weather point already exists in sects
	exists = false
	for each section in sects
	{
		for each sectionPoint in section
		{
			if (point.Position == sectionPoint.Position)
			{
				exists = true
				//don't check rest of points if already detected it exists
				break
			}
		}
		if (exists)
		{
		//don't check other points if already detected that it exists
		break
		}
	}
	if (!exists)
	{
		//add section to list of sections
		sects.Add(MakeSection(point, new List<Point>()))
	}
}
return sects
endfunction
\end{lstlisting}
\textit{Recursive algorithm for detecting a section, given a starting point}
\begin{lstlisting}
function MakeSection(Point startPoint, List<Point> exclude)
List<Point> NewPoints = new List<Point>()
//add current startPoint to list of points to exclude
exclude.Add(point)
for each point in startPoint.Connectedpoints
{
	//branch out when point isn't already detected and is connected
	if exclude does not contain point
	{
		NewPoints = MakeSection(point, exclude)
		for each newPoint in NewPoints
		{
			if (newPoint doesn't exist in NewPoints)
			{
				exclude.Add(newPoint)
			}
		}
	}
}
return exclude
endfuntion
\end{lstlisting}
Now that I am able to detect sections we want to connect them. This is done by saving the list of edges from the triangulation section and finding the difference between the list after removing edges.
\linebreak
\begin{lstlisting}
//code called once before main loop is started
//polygon is all the edge after triangulated
//polygonEdgeList are the edges left over after deleting a random amount
//polygonDifference is polygon - polygonEdgeList
List<Edge> polygonDifference(polygon, polygonEdgeList)
List<List<Point>> sections = DetectSections(polygonEdgeList)

//code inside the main loop that runs every frame
if (sections.Count != 1)
{
	//need to add points until there is only one section left
	int index = RandIntInRange(0,polygonDifference.Count - 1)
	//remove random edge from polygonDifference and add it to polygonEdgeList
	polygonEdgeList.Add(polygonDifference[index])
	polygonDifference.RemoveAtIndex(index)
	sections = DetectSections(polygonEdgeList)
}
else
{
	//remove rooms with no edges connected to them
	List<Point> graph = MakeGraph(polygonEdgeList)
	//all rooms are represented with an Area2D data type (custom structure made by godot) and need to check if children(the rooms) of the object are a point in the edgeList
	for each child in GetChildren
	{
		if (a point in graph doesn't have same position as a child)
		{
			//In this case the child isn't considered for in the edgeList
			RemoveChild(child)
		}
	}
	//move onto the next stage of generation
}
\end{lstlisting}

\section{Designing a solution}

\section{Evaluation}
\end{document}















